import logging
import re
from typing import Dict, List

class PromptAnalyzer:
    """Analyzes prompt characteristics and patterns"""
    
    def analyze_prompt_characteristics(self, prompt: str, features: Dict) -> Dict:
        """
        Perform comprehensive prompt analysis.
        
        Args:
            prompt (str): Input text
            features (Dict): Extracted features
            
        Returns:
            Dict: Analysis results including length, ratios, and risk factors
        """
        logging.info(f"Analyzing prompt characteristics for text length: {len(prompt)}")
        
        analysis = {
            "length": len(prompt),
            "special_char_ratio": features["special_char_ratio"],
            "keyword_density": features["keyword_density"],
            "repetition_score": features["repetition_score"],
            "structure_complexity": features["structure_complexity"],
            "risk_factors": self._analyze_risk_factors(prompt, features),
            "pattern_matches": self._analyze_patterns(prompt)
        }
        
        if "bert_features" in features:
            logging.info("Adding BERT-specific analysis")
            analysis["semantic_analysis"] = {
                "attention_patterns": features["bert_features"]["attention"],
                "semantic_complexity": features["bert_features"]["complexity"]
            }
            
        logging.info("Prompt characteristics analysis completed")
        return analysis
    
    def _analyze_patterns(self, prompt: str) -> Dict:
        """
        Find suspicious patterns in text.
        
        Args:
            prompt (str): Input text
            
        Returns:
            Dict: Detected patterns by category
        """
        logging.info("Analyzing prompt patterns")
        patterns = {
            "command_patterns": self._find_command_patterns(prompt),
            "manipulation_patterns": self._find_manipulation_patterns(prompt),
            "obfuscation_attempts": self._detect_obfuscation(prompt)
        }
        logging.info(f"Found {sum(len(p) if isinstance(p, list) else 1 for p in patterns.values())} total patterns")
        return patterns
    
    def _find_command_patterns(self, prompt: str) -> List[str]:
        """
        Detect system command patterns.
        
        Args:
            prompt (str): Input text
            
        Returns:
            List[str]: Matched command patterns
        """
        logging.info("Checking for command patterns")
        command_patterns = [
            r"system\s*\(",
            r"exec\s*\(",
            r"eval\s*\(",
            r"shell\s*\(",
            r"\bsudo\b",
            r"\bchmod\b",
            r"\brm\s+-rf\b"
        ]
        matches = [pattern for pattern in command_patterns 
                if re.search(pattern, prompt, re.IGNORECASE)]
        logging.info(f"Found {len(matches)} command patterns")
        return matches
    
    def _find_manipulation_patterns(self, prompt: str) -> List[str]:
        """
        Detect AI manipulation attempts.
        
        Args:
            prompt (str): Input text
            
        Returns:
            List[str]: Matched manipulation patterns
        """
        logging.info("Checking for manipulation patterns")
        manipulation_patterns = [
            r"ignore .*previous",
            r"forget .*training",
            r"you are now",
            r"new personality",
            r"override .*settings"
        ]
        matches = [pattern for pattern in manipulation_patterns 
                if re.search(pattern, prompt, re.IGNORECASE)]
        logging.info(f"Found {len(matches)} manipulation patterns")
        return matches
    
    def _detect_obfuscation(self, prompt: str) -> Dict:
        """
        Detect text obfuscation attempts.
        
        Args:
            prompt (str): Input text
            
        Returns:
            Dict: Obfuscation techniques found
        """
        logging.info("Checking for obfuscation techniques")
        techniques = {
            "zero_width_spaces": "\u200b" in prompt,
            "unusual_unicode": bool(re.search(r'[^\x00-\x7F]', prompt)),
            "repeated_characters": bool(re.search(r'(.)\1{4,}', prompt)),
            "hidden_commands": bool(re.search(r'[`\'"].*[`\'"]', prompt))
        }
        logging.info(f"Found {sum(techniques.values())} obfuscation techniques")
        return techniques
    
    def _analyze_risk_factors(self, prompt: str, features: Dict) -> List[Dict]:
        """
        Analyze security risk factors.
        
        Args:
            prompt (str): Input text
            features (Dict): Extracted features
            
        Returns:
            List[Dict]: Risk factors with severity and details
        """
        logging.info("Analyzing risk factors")
        risk_factors = []
        
        if features["has_system_commands"]:
            risk_factors.append({
                "type": "system_command",
                "severity": "high",
                "details": "Contains system-level command patterns",
                "matches": self._find_command_patterns(prompt)
            })
            
        if features["has_role_manipulation"]:
            risk_factors.append({
                "type": "role_manipulation",
                "severity": "high",
                "details": "Attempts to manipulate AI role/identity",
                "matches": self._find_manipulation_patterns(prompt)
            })
            
        obfuscation = self._detect_obfuscation(prompt)
        if any(obfuscation.values()):
            risk_factors.append({
                "type": "obfuscation",
                "severity": "medium",
                "details": "Potential obfuscation techniques detected",
                "techniques": obfuscation
            })
            
        logging.info(f"Found {len(risk_factors)} risk factors")
        return risk_factors
