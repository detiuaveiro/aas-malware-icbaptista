import re
import math
import logging
from typing import Dict, List
from collections import Counter

class FeatureExtractor:
    """Feature extraction specifically for prompt injection detection in text prompts."""
    
    def __init__(self):
        """Initialize patterns focused on prompt injection techniques"""
        # Role/behavior manipulation patterns
        self.role_patterns = [
            r'ignore .*?instructions',
            r'disregard .*?(training|rules)',
            r'forget .*?(rules|instructions|training)',
            r'you (must|will|should) now',
            r'from now on you (are|will|must)',
            r'you will act as',
            r'override .*?instructions',
            r'new instructions:',
            r'your (only )?purpose is',
            r'do not follow',
            r'your new role is',
            r'pretend to be',
            r'stop being',
            r'bypass restrictions'
        ]
        
        # Output/context manipulation patterns
        self.context_patterns = [
            r'output (in|as) (\w+)',  # Force output format
            r'respond without',
            r'no disclaimers',
            r'do not include',
            r'skip verification',
            r'avoid mentioning',
            r'don\'t check',
            r'ignore validity',
            r'don\'t mention',
            r'remove all'
        ]
        
        # Delimiter and formatting patterns
        self.delimiter_patterns = [
            r'\[.*?\]',      # Square brackets
            r'\{.*?\}',      # Curly braces
            r'<.*?>',        # Angle brackets
            r'".*?"',        # Double quotes
            r'\'.*?\'',      # Single quotes
            r'```.*?```',    # Code blocks
            r'\$.*?\$',      # Dollar signs
            r'\|.*?\|'       # Pipe characters
        ]
        
        # Emotional manipulation keywords
        self.manipulation_keywords = {
            'please', 'urgent', 'important', 'must', 'need',
            'help', 'emergency', 'critical', 'required',
            'necessary', 'crucial', 'vital', 'essential',
            'immediate', 'asap', 'quickly'
        }
        
        # Hidden characters and Unicode tricks
        self.hidden_chars = {
            '\u200B': 'zero-width space',
            '\u200C': 'zero-width non-joiner',
            '\u200D': 'zero-width joiner',
            '\u2060': 'word joiner',
            '\u200E': 'left-to-right mark',
            '\u200F': 'right-to-left mark'
        }
        
        # Compile regex patterns
        self.role_regex = [re.compile(p, re.IGNORECASE) for p in self.role_patterns]
        self.context_regex = [re.compile(p, re.IGNORECASE) for p in self.context_patterns]
        self.delimiter_regex = [re.compile(p) for p in self.delimiter_patterns]
        
        logging.info("FeatureExtractor initialized with prompt injection patterns")
        
    def extract_features(self, prompt: str) -> Dict:
        """
        Extract prompt injection relevant features from input text.
        
        Args:
            prompt (str): Input text to analyze
            
        Returns:
            Dict: Feature dictionary containing:
                - role_manipulation_score: Attempts to change AI behavior
                - context_manipulation_score: Attempts to alter output/context
                - delimiter_score: Use of potential instruction delimiters
                - emotional_manipulation: Use of urgency/emotional language
                - hidden_chars_present: Hidden character detection
                - repetition_score: Repeated pattern detection
                - text_structure: Text structure analysis
                - token_count: Approximate token count
        """
        features = {
            'text': prompt,  
            'role_manipulation_score': self._check_role_manipulation(prompt),
            'context_manipulation_score': self._check_context_manipulation(prompt),
            'delimiter_score': self._check_delimiters(prompt),
            'emotional_manipulation': self._check_emotional_manipulation(prompt),
            'hidden_chars_present': self._check_hidden_characters(prompt),
            'repetition_score': self._calculate_repetition(prompt),
            'text_structure': self._analyze_text_structure(prompt),
            'token_count': len(prompt.split())
        }
        
        return features
    
    def _check_role_manipulation(self, text: str) -> float:
        """Check for attempts to manipulate AI's role/behavior"""
        matches = sum(bool(pattern.search(text)) for pattern in self.role_regex)
        return matches / len(self.role_regex)
    
    def _check_context_manipulation(self, text: str) -> float:
        """Check for attempts to manipulate output/context"""
        matches = sum(bool(pattern.search(text)) for pattern in self.context_regex)
        return matches / len(self.context_regex)
    
    def _check_delimiters(self, text: str) -> float:
        """Check for use of potential instruction delimiters"""
        matches = sum(bool(pattern.search(text)) for pattern in self.delimiter_regex)
        return matches / len(self.delimiter_regex)
    
    def _check_emotional_manipulation(self, text: str) -> float:
        """Check for emotional manipulation attempts"""
        words = text.lower().split()
        if not words:
            return 0.0
        manipulation_count = sum(1 for word in words if word in self.manipulation_keywords)
        return manipulation_count / len(words)
    
    def _check_hidden_characters(self, text: str) -> float:
        """Check for hidden/zero-width characters"""
        hidden_count = sum(text.count(char) for char in self.hidden_chars)
        return hidden_count / len(text) if text else 0.0
    
    def _calculate_repetition(self, text: str) -> float:
        """Calculate text pattern repetition"""
        if not text:
            return 0.0
        words = text.lower().split()
        if not words:
            return 0.0
        word_counts = Counter(words)
        max_repeat = max(word_counts.values())
        return max_repeat / len(words)
    
    def _analyze_text_structure(self, text: str) -> float:
        """Analyze text structure for potential manipulation"""
        # Check for unusual formatting
        newline_ratio = text.count('\n') / len(text) if text else 0
        space_ratio = text.count(' ') / len(text) if text else 0
        special_char_ratio = sum(1 for c in text if not c.isalnum()) / len(text) if text else 0
        
        # Combine metrics
        return (newline_ratio + space_ratio + special_char_ratio) / 3
    
    def get_feature_names(self) -> List[str]:
        """Get list of feature names"""
        return [
            'role_manipulation_score',
            'context_manipulation_score',
            'delimiter_score',
            'emotional_manipulation',
            'hidden_chars_present',
            'repetition_score',
            'text_structure',
            'token_count'
        ]