# src/features/feature_extractor.py
"""
Feature extraction module for detecting potential prompt injection and malicious content.
This module analyzes text, binary, and PDF content for suspicious patterns.
"""
import re
import math 
import logging
from datetime import datetime
from typing import Dict, List
from ..utils.patterns import INJECTION_PATTERNS

class FeatureExtractor:
    """
    A class for extracting and analyzing features from various content types.
    
    Attributes:
        patterns (Dict): Predefined patterns for detection
    """
    
    def __init__(self):
        """Initialize with injection detection patterns."""
        self.patterns = INJECTION_PATTERNS
        logging.info("FeatureExtractor initialized")
        
    def extract_features(self, prompt: str) -> Dict[str, float]:
        """
        Extract security-relevant features from input text.
        
        Args:
            prompt (str): Input text to analyze
            
        Returns:
            Dict[str, float]: Feature dictionary with scores
                - length: Total character count
                - has_system_commands: Boolean for system command presence
                - has_role_manipulation: Boolean for role change attempts
                - special_char_ratio: Ratio of special characters
                - keyword_density: Density of suspicious keywords
                - repetition_score: Text repetition measure
                - structure_complexity: Structural analysis score
                - unicode_anomalies: Boolean for Unicode manipulation
                - hidden_whitespace: Boolean for hidden characters
                - encoding_attempts: Boolean for encoding tricks
                - context_manipulation: Boolean for context manipulation
        """
        logging.info("Starting feature extraction...")
        features = {
            "length": len(prompt),
            "has_system_commands": self._check_system_commands(prompt),
            "has_role_manipulation": self._check_role_manipulation(prompt),
            "special_char_ratio": self._calculate_special_char_ratio(prompt),
            "keyword_density": self._calculate_keyword_density(prompt),
            "repetition_score": self._calculate_repetition(prompt),
            "structure_complexity": self._analyze_structure(prompt),
            "unicode_anomalies": self._check_unicode_manipulation(prompt),
            "hidden_whitespace": self._check_hidden_whitespace(prompt),
            "encoding_attempts": self._check_encodings(prompt),
            "context_manipulation": self._check_context_manipulation(prompt)
        }
        logging.info("Feature extraction completed")
        return features

    def _check_system_commands(self, prompt: str) -> bool:
        """
        Detect system command patterns in text.
        
        Args:
            prompt (str): Input text
            
        Returns:
            bool: True if system commands found
        """
        logging.info("Checking system commands...")
        result = any(pattern.search(prompt.lower()) 
                  for pattern in self.patterns["system_commands"])
        logging.info(f"System command check result: {result}")
        return result

    def _check_role_manipulation(self, prompt: str) -> bool:
        """
        Detect attempts to manipulate AI role/identity.
        
        Args:
            prompt (str): Input text
            
        Returns:
            bool: True if role manipulation detected
        """
        logging.info("Checking role manipulation...")
        result = any(pattern.search(prompt.lower()) 
                  for pattern in self.patterns["role_manipulation"])
        logging.info(f"Role manipulation check result: {result}")
        return result

    def _calculate_special_char_ratio(self, prompt: str) -> float:
        """
        Calculate ratio of special characters to total length.
        
        Args:
            prompt (str): Input text
            
        Returns:
            float: Ratio (0.0-1.0) of special characters
        """
        logging.info("Calculating special character ratio...")
        special_chars = sum(1 for c in prompt if not c.isalnum() and not c.isspace())
        ratio = special_chars / len(prompt) if len(prompt) > 0 else 0
        logging.info(f"Special character ratio: {ratio:.4f}")
        return ratio

    def _calculate_keyword_density(self, prompt: str) -> float:
        """
        Calculate density of suspicious keywords.
        
        Args:
            prompt (str): Input text
            
        Returns:
            float: Ratio (0.0-1.0) of suspicious keywords
        """
        logging.info("Calculating keyword density...")
        keywords = self.patterns["suspicious_keywords"]
        word_count = len(prompt.split())
        keyword_count = sum(1 for word in prompt.lower().split() 
                          if word in keywords)
        density = keyword_count / word_count if word_count > 0 else 0
        logging.info(f"Keyword density: {density:.4f}")
        return density

    def _calculate_repetition(self, prompt: str) -> float:
        """
        Calculate text repetition score.
        
        Args:
            prompt (str): Input text
            
        Returns:
            float: Repetition score (0.0-1.0)
        """
        logging.info("Calculating repetition score...")
        words = prompt.lower().split()
        if not words:
            logging.info("Empty prompt, repetition score: 0")
            return 0
        unique_words = len(set(words))
        score = 1 - (unique_words / len(words))
        logging.info(f"Repetition score: {score:.4f}")
        return score

    def _analyze_structure(self, prompt: str) -> float:
        """
        Analyze structural complexity (nested patterns).
        
        Args:
            prompt (str): Input text
            
        Returns:
            float: Complexity score (0.0-1.0)
        """
        logging.info("Analyzing structure...")
        # TODO: Implement structure analysis
        logging.info("Structure analysis completed")
        return 0.0

    def analyze_binary_patterns(self, content: bytes) -> Dict[str, float]:
        """
        Analyze binary content for suspicious patterns.
        
        Args:
            content (bytes): Binary data
            
        Returns:
            Dict[str, float]: Analysis results
                - entropy: Shannon entropy
                - suspicious_sequences: Anomaly score
                - structure_validity: Structure check score
        """
        logging.info("Starting binary analysis...")
        patterns = {
            "entropy": self._calculate_entropy(content),
            "suspicious_sequences": self._find_suspicious_sequences(content),
            "structure_validity": self._check_file_structure(content)
        }
        logging.info("Binary analysis completed")
        return patterns

    def _calculate_entropy(self, data: bytes) -> float:
        """
        Calculate Shannon entropy of binary data.
        
        Args:
            data (bytes): Binary content
            
        Returns:
            float: Entropy value
        """
        logging.info("Calculating entropy...")
        if not data:
            logging.info("Empty data, entropy: 0")
            return 0.0
        entropy = 0
        for x in range(256):
            p_x = data.count(x) / len(data)
            if p_x > 0:
                entropy += -p_x * math.log2(p_x)
        logging.info(f"Entropy: {entropy:.4f}")
        return entropy

    def analyze_pdf_content(self, pdf_content: bytes) -> Dict[str, bool]:
        """
        Analyze PDF content for malicious elements.
        
        Args:
            pdf_content (bytes): PDF data
            
        Returns:
            Dict[str, bool]: Analysis results
                - has_javascript: JavaScript presence
                - has_embedded_files: Embedded files check
                - has_suspicious_streams: Stream analysis
                - structure_anomalies: Structure validation
        """
        logging.info("Starting PDF analysis...")
        features = {
            "has_javascript": self._check_javascript(pdf_content),
            "has_embedded_files": self._check_embedded_files(pdf_content),
            "has_suspicious_streams": self._check_suspicious_streams(pdf_content),
            "structure_anomalies": self._check_pdf_structure(pdf_content)
        }
        logging.info("PDF analysis completed")
        return features

    def _check_javascript(self, content: bytes) -> bool:
        """
        Check for JavaScript in PDF content.
        
        Args:
            content (bytes): PDF data
            
        Returns:
            bool: True if JavaScript detected
        """
        logging.info("Checking JavaScript...")
        js_patterns = [b"/JavaScript", b"/JS ", b"app.", b"eval("]
        result = any(pattern in content for pattern in js_patterns)
        logging.info(f"JavaScript check result: {result}")
        return result

    def _check_embedded_files(self, content: bytes) -> bool:
        """
        Check for embedded files in PDF.
        
        Args:
            content (bytes): PDF data
            
        Returns:
            bool: True if embedded files found
        """
        logging.info("Checking embedded files...")
        result = b"/EmbeddedFiles" in content or b"/FileSpec" in content
        logging.info(f"Embedded files check result: {result}")
        return result

    def _check_encodings(self, prompt: str) -> bool:
        """
        Check for encoding manipulation attempts.
        
        Args:
            prompt (str): Input text
            
        Returns:
            bool: True if suspicious encodings found
        """
        logging.info("Checking encodings...")
        patterns = [
            r'\\x[0-9a-fA-F]{2}',  # Hex
            r'\\u[0-9a-fA-F]{4}',  # Unicode
            r'%[0-9a-fA-F]{2}',    # URL
            r'&#x[0-9a-fA-F]+;'    # HTML hex
        ]
        result = any(re.search(pattern, prompt) for pattern in patterns)
        logging.info(f"Encoding check result: {result}")
        return result

    def _check_unicode_manipulation(self, prompt: str) -> bool:
        """
        Check for Unicode character manipulation.
        
        Args:
            prompt (str): Input text
            
        Returns:
            bool: True if suspicious Unicode chars found
        """
        logging.info("Checking Unicode manipulation...")
        suspicious_chars = {
            '？': '?',  # Question mark
            'А': 'A',  # Cyrillic A
            'е': 'e'   # Cyrillic e
        }
        result = any(char in prompt for char in suspicious_chars)
        logging.info(f"Unicode check result: {result}")
        return result

    def _check_hidden_whitespace(self, prompt: str) -> bool:
        """
        Check for hidden whitespace characters.
        
        Args:
            prompt (str): Input text
            
        Returns:
            bool: True if hidden whitespace found
        """
        logging.info("Checking hidden whitespace...")
        hidden_chars = [
            '\u200B',  # Zero-width space
            '\u200C',  # Zero-width non-joiner
            '\u200D'   # Zero-width joiner
        ]
        result = any(char in prompt for char in hidden_chars)
        logging.info(f"Hidden whitespace check result: {result}")
        return result

    def _check_context_manipulation(self, prompt: str) -> bool:
        """
        Check for context/instruction manipulation attempts.
        
        Args:
            prompt (str): Input text
            
        Returns:
            bool: True if context manipulation detected
        """
        logging.info("Checking context manipulation...")
        patterns = [
            r'ignore previous',
            r'disregard .*instructions',
            r'forget .*rules',
            r'bypass .*restrictions',
            r'override .*settings',
            r'new instructions:',
            r'your new role is',
            r'you will now act as',
            r'you must ignore',
            r'do not follow'
        ]
        result = any(re.search(pattern, prompt.lower()) for pattern in patterns)
        logging.info(f"Context manipulation check result: {result}")
        return result