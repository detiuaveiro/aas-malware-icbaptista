
# src/models/classifier.py
import numpy as np
from typing import Tuple
from sklearn.ensemble import RandomForestClassifier

class InjectionClassifier:
    def __init__(self):
        self.model = RandomForestClassifier()
        self.is_trained = False
        
    def train(self, X, y):
        """
        Train the classifier on feature vectors.
        """
        self.model.fit(X, y)
        self.is_trained = True
    
    def predict(self, features: dict) -> Tuple[float, str]:
        """
        Predict risk score and classification for feature vector.
        """
        # Convert features to vector
        feature_vector = self._prepare_feature_vector(features)
        
        # Get prediction probability
        if self.is_trained:
            risk_score = self.model.predict_proba([feature_vector])[0][1]
            prediction = "malicious" if risk_score > 0.5 else "benign"
        else:
            # Fallback to rule-based scoring if model isn't trained
            risk_score = self._rule_based_score(features)
            prediction = "malicious" if risk_score > 0.5 else "benign"
            
        return risk_score, prediction
    
    def _prepare_feature_vector(self, features: dict) -> np.ndarray:
        """
        Convert feature dictionary to numpy array.
        """
        # Define feature order and convert to array
        feature_order = [
            "length", "special_char_ratio", "keyword_density",
            "repetition_score", "structure_complexity"
        ]
        return np.array([features[f] for f in feature_order])
    
    def _rule_based_score(self, features: dict) -> float:
        """
        Calculate risk score based on rules when model isn't trained.
        """
        score = 0.0
        
        # Add weight for each suspicious feature
        if features["has_system_commands"]:
            score += 0.4
        if features["has_role_manipulation"]:
            score += 0.3
        if features["special_char_ratio"] > 0.3:
            score += 0.2
        if features["keyword_density"] > 0.1:
            score += 0.1
            
        return min(score, 1.0)
